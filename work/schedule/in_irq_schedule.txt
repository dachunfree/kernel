CPU0:

/* thread A*/
spin_lock(lock);
/* do something */

        /* interrupted by hardirq */
        schedule();
        /* switch to B thread*/
        spin_lock(lock);
        /* what happened? */
/* do something */
spin_unlock(lock);


说到这个中断栈是是用进程栈还是中断栈，就想起一个问题，中断上下文调度还能不能回来！就需要考虑这个栈的情况

长剑:
一般有独立的中断栈是回不去的

长剑:
没有独立的栈排除死锁等问题或许可以回去

长剑:
还有就是中断睡眠会导致比较大的调度延迟

smcdef:
中断调度的话，用进程栈一般是可以调度回来的！

长剑:
排除死锁等问题可以回去

长剑:
但是会造成比较大的调度延迟

长剑:
所以一般还是不要这么干

英雄本色:
不一定，有抢占点，可能不回到原来的进程。。


长剑:
@宋牧春?没有，只是看看


长剑:
只记得一个结论了

钢铁侠:
上下文被覆盖了

长剑:
卧槽，你记忆力真好

钢铁侠:
日经问题

长剑:
不是月经嘛

smcdef:
有想过上下文为什么被覆盖吗？

smcdef:
中断又发生了

smcdef:
所以....

钢铁侠:
是的

长剑:
楼上两位大侠

长剑:
看来大家都思考过同样的问题

smcdef:
有没有想过中断还没发生，能不能回来呢

钢铁侠:
有一定概率回来

长剑:
这要看

钢铁侠:
之前测试过中断sleep

钢铁侠:
有一定概率不死机，可以回来，大部分系统挂了

甜食最棒:
所以是，用独立的中断栈有一定的概率回来，如果中断了还再中断一次，那就上下文被覆盖了

甜食最棒:
是这个意思？

京北韩郎:
中断里不是中断是被禁止的了么。

长剑:
调度会重新开启

长剑:
调度最后会开中断

甜食最棒:
「 宋牧春: 有想过上下文为什么被覆盖吗？ 」
- - - - - - - - - - - - - - -
这个答案是啥

长剑:
不然如果中断关的，定时器中断都被灭了，

长剑:
整个调度器都废了

京北韩郎:
@饶磊?这样额。

京北韩郎:
没想到这里。

长剑:
所以之前很多认为中断回不去是因为关中断，因为定时器，都是不对的

京北韩郎:
这是关键点。

长剑:
@张翼德 你测试是在X86上测试吗

钢铁侠:
对

甜食最棒:
「 甜食最棒: 「 宋牧春: 有想过上下文为什么被覆盖吗？ 」
- - - - - - - - - - - - - - -
这个答案是啥 」
- - - - - - - - - - - - - - -
有人说一下嘛

smcdef:
调度的时候会主动打开中断，所以中断发生就会覆盖

甜食最棒:
哦哦

长剑:
所以就是看运气了

长剑:
没中断就回去了，恰好来个中断，就完蛋了

长剑:
这就是月经问题

甜食最棒:
现在还有不是独立中断栈的了嘛

长剑:
不过杨勇说，也可能调度的时候也可能引起死锁

长剑:
ARM不知道最新的是不是独立的中断栈，我看的资料还是说共享内核栈

甜食最棒:
对 arm不是

smcdef:
我记得ARM32是共享的

smcdef:
ARM64是独立的

长剑:
arm64就不了解了

京北韩郎:
各个不同的进程必须一人一栈，各种不同的中断却可以共享一个栈，是因为，中断不可打断吧

京北韩郎:
每次中断完，栈都是干净的

京北韩郎:
嵌套也可以说的通。

甜食最棒:
「 京北韩郎: 各个不同的进程必须一人一栈，各种不同的中断却可以共享一个栈，是因为，中断不可打断吧 」
- - - - - - - - - - - - - - -
我看书上说，中断栈独立出来的原因是，减少内存压力

阿克曼:
@甜食最棒 那本书？？

甜食最棒:
「 人类最强: @甜食最棒 那本书？？ 」
- - - - - - - - - - - - - - -
内核设计与实现

京北韩郎:
@甜食最棒?我看看书，没太理解独立栈的好处。

甜食最棒:
独立中断栈的引入 和 嵌套 有啥关系。。。

甜食最棒:
就是内存压力大

长剑:
嵌套多了，容易爆栈吧

smcdef:
是的

smcdef:
然后，内存压力不就大了

京北韩郎:
可能要考虑宿主进程的栈压力了，如果进程都很紧张，中断再用

长剑:
我记得分开就是防止爆栈

甜食最棒:
书上没说这个，不过，分开了嵌套多了不会爆栈？

京北韩郎:
饶大说的嵌套，可能是进程嵌套，栈快满了，中断再
占用

甜食最棒:
那分开了 不也是一样的情况吗

我是坑货:
你说的分开防止爆栈是止内核栈吧？比如A进程下到内核，执行了一堆函数压了栈没有出来，发生了进程切换，换到B进程，B又下到内核，这个时候栈已经被用了，但是里面压的东西和B将要执行的点关系都没有

长剑:
对，肯定是爆内核栈呀

甜食最棒:
我不太认同，原先内核栈是两页，独立之后为1页，我觉得很少很少情况能做到爆栈的情况，之前的设计应该是预留了不少的

京北韩郎:
@肖立?B不是用的自己内核栈么，跟A是不是没关系

甜食最棒:
书上原话是：因为系统中每个进程原先都需要两页连续，且不可患处的内核内存。为了应对栈大小的减少，中断。。。。。。。。

我是坑货:
我的意思就是，如果不分开，那么可能出现爆栈

长剑:
所以甜食的意思是

长剑:
这样分开

长剑:
可以少用了很多内存

京北韩郎:
嗯。

甜食最棒:
是的

我是坑货:
甜食说的独立是中断栈吧？

长剑:
那本书，我看看

我是坑货:
为什么中断要从进程内核栈中独立出来

长剑:
我好久没看书了

京北韩郎:
是的，大家说的独立中断栈


