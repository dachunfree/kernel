lru链表的组成:
https://www.cnblogs.com/tolimit/p/5447448.html 

lru缓存
　　上面说到，当需要修改lru链表时，一定要占有zone中的lru_lock这个锁，在多核的硬件环境中，在同时需要对lru链表进行修改时，
锁的竞争会非常的频繁，所以内核提供了一个lru缓存的机制，这种机制能够减少锁的竞争频率。其实这种机制非常简单，lru缓存相当于
将一些需要相同处理的页集合起来，当达到一定数量时再对它们进行一批次的处理，这样做可以让对锁的需求集中在这个处理的时间点，
而没有lru缓存的情况下，则是当一个页需要处理时则立即进行处理，对锁的需求的时间点就会比较离散。首先为了更好的说明lru缓存，
先对lru链表进行操作主要有以下几种：

*将不处于lru链表的新页放入到lru链表中
*将非活动lru链表中的页移动到非活动lru链表尾部(活动页不需要这样做，后面说明)
*将处于活动lru链表的页移动到非活动lru链表
*将处于非活动lru链表的页移动到活动lru链表
*将页从lru链表中移除

这样就会涉及到一个问题，由于页被访问时，访问了此页的进程对应此页的页表项中的Accessed会置位，表面此页被访问了，而lru链表
只有在进行内存回收时才会进行判断，那就会有一种情况，在一个小时之内，内存空闲页富足，这一个小时中都没有发生内存回收，而这
一个小时中，所有进程使用的内存页都进行过了访问，也就是每个页反向映射到进程页表项中总能找到有进程访问过此页，这时候内存回
收开始了，lru链表如何将这些页判断为活动页还是非活动页？可以说，在这种情况，第一轮内存回收基本上颗粒无收，因为所有页都会被
判定为活动页，但是当第二轮内存回收时，就可以正常判断了，因为每一轮内存回收后，都会清除所有访问了此页的页表项的Accessed标志，
在第二轮内存回收时，只有在第一轮内存回收后与第二轮内存回收开始前被访问过的页，才会被判断为最近被访问过的页。

