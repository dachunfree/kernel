bootmem_init
   |----->min = PFN_UP(memblock_start_of_DRAM());
   |----->max = PFN_DOWN(memblock_end_of_DRAM());
   |      获取最大，最小页号
   |----->arm64_memory_present();
   |      遍历所有的memory region，每个memory region换分成1G大小的section，并设置section在位
   |   |----->sparse_index_init(section, nid);
   |   |      遍历所有的section，为其分配"struct mem_section"实例，这里有两点需要注意
   |   |      1. 如果memory region不是按section对齐的，那么最后一个section会有空洞，即没有对应的物理页
   |   |      2. SECTIONS_PER_ROOT即一个物理页面可以存放多少"struct mem_section"实例，由于目前内存是按
   |   |         物理页面来管理的，所以一次会分配一个物理页面来存放"struct mem_section"实例，称为一个
   |   |         ROOT，如果"struct mem_section"实例很多的话，可能需要分配多个物理页面
   |   |----->ms->section_mem_map = sparse_encode_early_nid(nid) | SECTION_MARKED_PRESENT;
   |   |      设置section在位
   |----->sparse_init();
   |   |----->size = sizeof(unsigned long *) * NR_MEM_SECTIONS;
   |   |      NR_MEM_SECTIONS是最大的section的数量，在ARM64上下文，一个section是1G
   |   |----->usemap_map = memblock_virt_alloc(size, 0);
   |   |      usemap_map是一个二维指针，这里实际上为所有可能存在的section分配了
   |   |      unsigned long类型的指针，可以看做指针数组
   |   |----->alloc_usemap_and_memmap(sparse_early_usemaps_alloc_node,
   |   |                        (void *)usemap_map);
   |   |      分别为各内存节点在位的所有section分配usemap_map空间，
   |   |      这里是调用sparse_early_usemaps_alloc_node来实现
   |   |   |----->int size = usemap_size();
   |   |   |      计算一个section需要多少空间。当前上下文，一个section有（1<<(30-12-10)）个
   |   |   |      pageblock，一个pageblock需要NR_PAGEBLOCK_BITS个bits来表示。
   |   |   |----->usemap = sparse_early_usemaps_alloc_pgdat_section(NODE_DATA(nodeid),
   |   |   |                         size * usemap_count);
   |   |   |      分配所需要的usemap空间
   |   |   |----->usemap_map[pnum] = usemap;
   |   |   |      每一个section指向其对应的usemap空间
   |   |   |----->map = sparse_early_mem_map_alloc(pnum);
   |   |   |      遍历所有的section，只要它在位，就为该section所有物理页面"struct page"实例分配空间
   |   |   |      分配空间包括虚拟地址空间和实际物理内存
   |   |   |   |----->map = sparse_mem_map_populate(pnum, nid);
   |   |   |   |   |----->map = pfn_to_page(pnum * PAGES_PER_SECTION);
   |   |   |   |   |      分配虚拟地址空间，如果定义了CONFIG_SPARSEMEM_VMEMMAP，则虚拟地址空间连续
   |   |   |   |   |----->start = (unsigned long)map;
   |   |   |   |   |----->end = (unsigned long)(map + PAGES_PER_SECTION);
   |   |   |   |   |----->vmemmap_populate(start, end, nid)
   |   |   |   |   |      将分配的虚拟地址映射到实际的物理内存
   |   |   |   |   |----->sparse_init_one_section(__nr_to_section(pnum), pnum, map, usemap);
   |   |   |   |   |   |----->ms->section_mem_map |= sparse_encode_mem_map(mem_map, pnum) | SECTION_HAS_MEM_MAP;
   |   |   |   |   |   |      section_mem_map指向为该section的"struct page"实例分配的空间，由于该地址至少是32bits对齐
   |   |   |   |   |   |      的，所以低bit可以另做他用，其中bit0表示section是否在位，bit1表示section是否硬件map过
   |   |   |   |   |   |      这里map过是指从section到page的map
   |   |   |   |   |   |----->ms->pageblock_flags = pageblock_bitmap;
   |   |   |   |   |   |      之前调用alloc_usemap_and_memmap为该section所有的pageblock分配的空间，用于记录pageblock的属性
   |----->zone_sizes_init(min, max);
   |   |----->max_dma = PFN_DOWN(arm64_dma_phys_limit);
   |   |----->zone_size[ZONE_DMA] = max_dma - min;
   |   |      计算DMA内存域size，该size指内存跨度，并不一定是实际的内存大小，
   |   |      因为中间可能有空洞。从内存起始物理地址开始，4G的内存空间分配给
   |   |      DMA域，如果总的内存空间小于4G，则所有的内存空间都分配给DMA内存
   |   |      域，这种情况下normal内存域size为0
   |   |----->zone_size[ZONE_NORMAL] = max - max_dma;
   |   |      计算normal内存域size，该size指内存跨度，并不一定是实际的内存大小，
   |   |      因为中间可能有空洞，normal内存域size可能为0
   |   |----->zhole_size[ZONE_DMA] -= dma_end - start;
   |   |----->zhole_size[ZONE_NORMAL] -= normal_end - normal_start;
   |   |      遍历memblock中所有的memory region，并分别计算dma内存域和normal内存
   |   |      域空洞的大小，空洞存在于region与region之间
   |   |----->free_area_init_node(0, zone_size, min, zhole_size);
   |   |   |   初始化内存节点，对于UMA系统来说，只有一个内存节点：contig_page_data
   |   |   |----->pgdat = NODE_DATA(nid);
   |   |   |      获取内存节点
   |   |   |----->pgdat->node_id = nid;
   |   |   |      内存节点号，UMA系统只有一个为0
   |   |   |----->pgdat->node_start_pfn = node_start_pfn;
   |   |   |      该内存节点起始页帧号
   |   |   |----->calculate_node_totalpages(pgdat, start_pfn, end_pfn,            
   |   |   |   |                              zones_size, zholes_size);
   |   |   |   |    一个内存节点包含多个内存域，该函数用于计算每一个内存域
   |   |   |   |    跨越多少个页帧，以及去除空洞后实际有多少页帧，将这些信息
   |   |   |   |    存入内存域结构体，同时统计所有内存域的页帧信息，存入内存
   |   |   |   |    节点结构体
   |   |   |   |----->zone->zone_start_pfn = zone_start_pfn;
   |   |   |   |      记录内存域起始页帧
   |   |   |   |----->zone->spanned_pages = size;
   |   |   |   |      记录内存域跨越多少页帧
   |   |   |   |----->zone->present_pages = real_size;
   |   |   |   |      记录内存域实际包含多少页帧
   |   |   |   |----->pgdat->node_spanned_pages = totalpages;
   |   |   |   |      记录该内存节点跨越多少页帧
   |   |   |   |----->pgdat->node_present_pages = realtotalpages;
   |   |   |   |      记录该内存节点实际包含多少页帧
   |   |   |----->free_area_init_core(pgdat);
   |   |   |   |     遍历该内存节点中的内一个内存域，并初始化，这里列出一个内存域的初始化示例
   |   |   |   |----->size = zone->spanned_pages;
   |   |   |   |----->realsize = freesize = zone->present_pages;
   |   |   |   |      size为该zone跨越的页数，realsize和freesize初始化为该zone实际包含的页数
   |   |   |   |----->memmap_pages = calc_memmap_size(size, realsize);
   |   |   |   |      每个物理page都有一个page结构体来表示，这里计算该内存域需要多少page来存储所有的page结构体
   |   |   |   |----->freesize -= memmap_pages;
   |   |   |   |      如果是非高端内存域，freesize要减去memmap_pages，也即预留memmap_pages个page
   |   |   |   |----->freesize -= dma_reserve;
   |   |   |   |      如果是第一个内存域，要为预留一段内存给DMA用。这是某些外设的DMA要求的，如果实际系统没有
   |   |   |   |      该需求，则不需要预留
   |   |   |   |----->nr_kernel_pages += freesize;
   |   |   |   |      如果是非高端内存域，可用的page数计入nr_kernel_pages，所有zone可以的page数都会计入
   |   |   |   |----->nr_kernel_pages -= memmap_pages;
   |   |   |   |      如果是高端内存域，在nr_kernel_pages充足的情况下，会预留memmap_pages，为高端内存page结构体
   |   |   |   |      预留存储空间，但是高端内存本身不会计入nr_kernel_pages。对于ARM64来说，高端内存意义不大，
   |   |   |   |      这里暂时不做详细介绍
   |   |   |   |----->nr_all_pages += freesize;
   |   |   |   |      所有内存域freesize都累加计入nr_all_pages，即所有可以用的page。在没有高端内存的情况下，
   |   |   |   |      nr_kernel_pages和nr_all_pages是一致的。
   |   |   |   |----->zone->managed_pages = is_highmem_idx(j) ? realsize : freesize;
   |   |   |   |      对于非高端内存来说，managed_pages指所有可用的page数
   |   |   |   |----->ret = init_currently_empty_zone(zone, zone_start_pfn, size);
   |   |   |   |      初始化该zone的free_area，该结构体是伙伴系统的核心。
   |   |   |   |----->memmap_init(size, nid, j, zone_start_pfn);
   |   |   |   |      所有的物理页帧，都会在软件上抽象出一个struct page实例，初始化struct page实例
   |   |   |   |   |----->__init_single_page(page, pfn, zone, nid);
   |   |   |   |   |      初始化一个page实例
   |   |   |   |   |----->set_pageblock_migratetype(page, MIGRATE_MOVABLE);
   |   |   |   |   |      设置pageblock迁移类型为MIGRATE_MOVABLE，一个pageblock有1024个page，及4M。
   |----->high_memory = __va((max << PAGE_SHIFT) - 1) + 1;
   |----->memblock_dump_all();


mem_section位二位数组：第一维是root page_block,第二维是page_block中的mem_section
mem_section[m][n]


page 0------------------------>|mem_section 0
page 1 												 |mem_section 1
page 2												 |.............
.....													 |.............
page m											   |mem_section n