https://blog.csdn.net/liuhangtiant/article/details/80561148

从dtb中的memory节点获取内存的起始地址，加入到memblock中。

可以看memblock结构体
memblock
 |----->bottom_up
 |      内存分配从高地址到低地址，还是从低地址到高地址
 |----->current_limit
 |      可以使用的内存的上限
 |----->memory
    |    记录完整的内存资源
    |----->cnt
    |       总的内存资源有几个region
    |----->max
    |       最多有几个region
    |----->total_size
    |       总的容量是多少
    |----->regions（128个大小）
       |----->base
       |       该memory region的基地址
       |----->size
       |       该memory region的容量
       |------>flags
       |       该memory region的flag
 |----->reserved（同上）
 |       记录已经分配或者预留的内存资源
 
Memblock中有两种内存类型, memory和reserved，memory用于记录总的内存资源，reserved用于记录已经使用或者预留的内存资源。

1.添加内存：memblock_add
memblock_add
   |-----> memblock_add_range
      |-----> type->regions[0].base = base;
      |-----> type->regions[0].size = size;
      |-----> type->regions[0].flags = flags;
      |-----> type->total_size = size;
      |        如果该类型memory第一个region为空，则填充该region并返回
   |-----> memblock_insert_region(type, idx, base, end - base, nid, flags)
   |       如果该类型memory第一个region不为空，则调用该函数插入如新的region
   |-----> memblock_merge_regions(type)
   |       如果相邻的region可以合并，则将其合并  
  
 插入region:
 a. region必须从大到小排列。这里说的大小，是指region所代表的内存的起始/结束地址，也就是说，region0的结束地址，必须小于
    或等于region1的起始地址
 b. 调用一次memblock_add，有可能将拆分成两个。
 

合并region:
如果前一个region的结束地址等于后一个region的开始地址，则将两个region合并。


删除内存：memblock_remove：


分配内存：memblock_alloc：
分配内存逻辑比较简单，主要分为两步：
a. 遍历memory类型内存的region，已经分配的内存以region的形式存放在rserved类型内存中.
b. 调用memblock_reserve函数将分配的内存以region的形式存放在rserved类型内存中

//no-map的memory在reserved中，但是不在memblock中？
arm64_memblock_init：
	|----->memblock_reserve(__pa(_text), _end - _text); //内核的加入到memory的中的 reserved区域
	|----->early_init_fdt_scan_reserved_mem
	 	 |----->fdt_get_mem_rsv(initial_boot_params, n, &base, &size); //扫描dtb中的reserved 内存区域(header中有);
		 |----->early_init_dt_reserve_memory_arch(base, size, 0); //将其加入到reserved 内存区域
		 |----->of_scan_flat_dt(__fdt_scan_reserved_mem, NULL); //逐个节点扫描，调用 __fdt_scan_reserved_mem 函数
		 		|---->__fdt_scan_reserved_mem
		 			 |----->strcmp(uname, "reserved-memory") //检测DTB是否为reserved-memory
		 			 |----->__reserved_mem_check_root //检测节点内部属性（#size-cells，#address-cells,ranges）
		 			 |----->of_get_flat_dt_prop(node, "status", NULL) //status节点是否为okay属性
		 			 |----->__reserved_mem_reserve_reg
		 			 		|----->of_get_flat_dt_prop(node, "reg", &len); //获取reg属性
		 			 		|----->of_get_flat_dt_prop(node, "no-map", NULL) //获取是否为no-map属性
		 			 		|-----> early_init_dt_reserve_memory_arch(base, size, nomap) //no-map从memory region中移除
		 			 		|----->fdt_reserved_mem_save_node //将first的 reserved memory节点保存起来
		 |----->fdt_init_reserved_mem